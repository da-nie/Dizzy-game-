#ifndef C_GAME_H
#define C_GAME_H

//****************************************************************************************************
//Класс игры
//****************************************************************************************************

//****************************************************************************************************
//подключаемые библиотеки
//****************************************************************************************************
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <vector>

#include "ivideo.h"
#include "cfontprinter.h"
#include "csprite.h"
#include "ipart.h"
#include "iconditionalexpression.h"
#include "cgamestate.h"

//****************************************************************************************************
//макроопределения
//****************************************************************************************************

//****************************************************************************************************
//константы
//****************************************************************************************************

//****************************************************************************************************
//предварительные объявления
//****************************************************************************************************

//****************************************************************************************************
//Класс игры
//****************************************************************************************************
class CGame
{
 public:
  //-перечисления---------------------------------------------------------------------------------------
  //-структуры------------------------------------------------------------------------------------------
  //-константы------------------------------------------------------------------------------------------
  static const int32_t DIZZY_WIDTH=25;
  static const int32_t DIZZY_HEIGHT=22;
    
  static const int32_t SCREEN_WIDTH=320;
  static const int32_t SCREEN_HEIGHT=240;

  static const int32_t TILE_WIDTH=16;//ширина тайла
  static const int32_t TILE_HEIGHT=16;//высота тайла
  static const int32_t TILE_BORDER_WIDTH=1;//ширина рамки
  static const int32_t TILE_BORDER_HEIGHT=1;//высота рамки  
  static const int32_t TILE_WITH_BORDER_WIDTH=TILE_WIDTH+TILE_BORDER_WIDTH+TILE_BORDER_WIDTH;//ширина тайла с рамкой
  static const int32_t TILE_WITH_BORDER_HEIGHT=TILE_HEIGHT+TILE_BORDER_HEIGHT+TILE_BORDER_HEIGHT;//высота тайла с рамкой

  static const int32_t USE_DELAY_COUNTER_MAX_VALUE=10;//максимальное значнение счётчика задержки до следующего нажатия кнопки "использовать"
 private:
  //-переменные-----------------------------------------------------------------------------------------
	   
  int32_t Map_X;//координаты левого верхнего угла карты
  int32_t Map_Y;

  CSprite cSprite_Dizzy;//спрайт Диззи
  CSprite cSprite_Frame;//рамки

  CSprite cSprite_Tiles;//тайлы
  CSprite cSprite_TilesBarrier;//непроницаемость тайлов
  
  int32_t X;//координаты Диззи
  int32_t Y;

  int32_t dX;//скорости Диззи
  int32_t dY;

  //режимы движения
  enum MOVE
  {
   MOVE_STOP,
   MOVE_LEFT,
   MOVE_RIGHT,
   MOVE_JUMP,
   MOVE_JUMP_LEFT,
   MOVE_JUMP_RIGHT,
  };

  bool MoveControl;//управляем ли Dizzy

  struct SFrame
  {   
   MOVE Move;//режим движения
   int32_t ImageFrame;//номер кадра в изображении
   SFrame *sFrame_Next_Ptr;//указатель на следующий кадр
   bool EndFrame;//является ли кадр последним кадром
   
   SFrame(int32_t image_frame,MOVE move,bool end_frame=false,SFrame *next_ptr=NULL)
   { 
    Move=move;
	ImageFrame=image_frame;
	sFrame_Next_Ptr=next_ptr;
	EndFrame=end_frame;
   }
  };
  
  SFrame *sFrame_Stop_Ptr;
  SFrame *sFrame_MoveLeft_Ptr;
  SFrame *sFrame_MoveRight_Ptr;
  SFrame *sFrame_Jump_Ptr;
  SFrame *sFrame_JumpLeft_Ptr;
  SFrame *sFrame_JumpRight_Ptr;

  SFrame *sFrame_Ptr;

  std::vector<SFrame> sFrame_Array;//набор кадров для анимации

  int32_t SmallTickCounter;//счётчик малого такта
  int32_t FlashTickCounter;//счётчик мигания
  
  std::vector<std::shared_ptr<IConditionalExpression> > ConditionalExpression;//набор условных выражений игровой логики
  std::shared_ptr<CFontPrinter> cFontPrinter_Ptr;//указатель на класс работы со шрифтами

  CGameState cGameState;//состояние игры

  uint32_t UseDelayCounter;//счётчик до следующего нажатия кнопки "использовать"
  
  bool InventoryMode;//режим работы с инвентарём
  int32_t InventorySelectedIndex;//выбранная позиция в инвентаре
 public:
  //-конструктор----------------------------------------------------------------------------------------
  CGame(void);
  //-деструктор-----------------------------------------------------------------------------------------
  ~CGame();
 public:
  //-открытые функции-----------------------------------------------------------------------------------
  void OnTimer(bool left,bool right,bool up,bool down,bool fire,IVideo *iVideo_Ptr);//обработка таймера  
 private:
  //-закрытые функции-----------------------------------------------------------------------------------  
  void OnPaint(IVideo *iVideo_Ptr);//отрисовать картинку  
  void KeyboardControl(bool left,bool right,bool up,bool down,bool fire);//управление от клавиатуры
  void PressUse(void);//нажата кнопка "использовать"
  void Processing(IVideo *iVideo_Ptr);//обработка игрового поля
  bool IsCollizionLegs(IVideo *iVideo_Ptr,int32_t xp,int32_t yp);//проверить столкновение с блоками ног Диззи
  bool IsCollizionBody(IVideo *iVideo_Ptr,int32_t xp,int32_t yp);//проверить столкновение с блоками корпуса Диззи
  bool LoadMap(const std::string &file_name);//загрузить карту
  void DrawBarrier(IVideo *iVideo_Ptr);//нарисовать преграды
  void DrawMap(IVideo *iVideo_Ptr);//нарисовать карту
  void DrawFirstPlaneMap(IVideo *iVideo_Ptr);//нарисовать карту переднего плана
  void DrawItemMap(IVideo *iVideo_Ptr);//нарисовать карту предметов
  void ClearScreen(IVideo *iVideo_Ptr,uint32_t color);//очистить экран
  void CreateConditionalExpression(void);//создать условные выражения
  void PutMessage(CGameState::SMessage &sMessage,IVideo *iVideo_Ptr);//вывод сообщения
  void PutFrame(int32_t x,int32_t y,int32_t text_width,int32_t text_height,IVideo *iVideo_Ptr);//нарисовать рамку с заданным внутренним полем для текста (x,y,text_width,text_height - зона вывода текста)
  void PutInventory(IVideo *iVideo_Ptr);//вывести инвентарь
  void SetDescription(const std::string &name,const std::string &description);//задать описание
};

#endif